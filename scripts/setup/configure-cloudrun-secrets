#!/bin/bash
#
# This script configures Zulip secrets for Cloud Run deployment
# It reads environment variables and creates the zulip-secrets.conf file

set -euo pipefail

SECRETS_FILE="/etc/zulip/zulip-secrets.conf"

echo "Configuring Zulip secrets for Cloud Run deployment..."

# Debug: Show available environment variables
echo "Available environment variables:"
env | grep -E "(POSTGRES|ZULIP|SHARED)" || echo "No relevant environment variables found"

# Ensure the /etc/zulip directory exists
sudo mkdir -p /etc/zulip

# Function to generate a random secret with multiple fallbacks
generate_secret() {
    local length=${1:-32}
    local secret=""
    
    # Try Python3 first
    if command -v python3 >/dev/null 2>&1; then
        echo "Trying Python3 for secret generation..." >&2
        secret=$(python3 -c "import secrets; print(secrets.token_urlsafe($length))" 2>/dev/null) && {
            if [ -n "$secret" ]; then
                echo "$secret"
                return 0
            fi
        }
    fi
    
    # Try OpenSSL as fallback
    if command -v openssl >/dev/null 2>&1; then
        echo "Trying OpenSSL for secret generation..." >&2
        secret=$(openssl rand -base64 $((length * 3 / 4)) 2>/dev/null | tr -d "=+/" | cut -c1-$length) && {
            if [ -n "$secret" ]; then
                echo "$secret"
                return 0
            fi
        }
    fi
    
    # Try /dev/urandom as last resort
    echo "Using /dev/urandom for secret generation..." >&2
    secret=$(head -c $length /dev/urandom 2>/dev/null | base64 | tr -d "=+/" | cut -c1-$length) && {
        if [ -n "$secret" ]; then
            echo "$secret"
            return 0
        fi
    }
    
    # If all else fails, generate a simple random string
    echo "Generating simple random string..." >&2
    echo "zulip_$(date +%s)_$(head -c 16 /dev/urandom 2>/dev/null | xxd -p 2>/dev/null || echo "fallback")"
}

# Function to generate a hex secret with multiple fallbacks
generate_hex_secret() {
    local length=${1:-32}
    local secret=""
    
    # Try Python3 first
    if command -v python3 >/dev/null 2>&1; then
        echo "Trying Python3 for hex secret generation..." >&2
        secret=$(python3 -c "import secrets; print(secrets.token_hex($length))" 2>/dev/null) && {
            if [ -n "$secret" ]; then
                echo "$secret"
                return 0
            fi
        }
    fi
    
    # Try OpenSSL as fallback
    if command -v openssl >/dev/null 2>&1; then
        echo "Trying OpenSSL for hex secret generation..." >&2
        secret=$(openssl rand -hex $length 2>/dev/null) && {
            if [ -n "$secret" ]; then
                echo "$secret"
                return 0
            fi
        }
    fi
    
    # Try xxd as fallback
    if command -v xxd >/dev/null 2>&1; then
        echo "Using xxd for hex secret generation..." >&2
        secret=$(head -c $length /dev/urandom 2>/dev/null | xxd -p 2>/dev/null | cut -c1-$((length * 2))) && {
            if [ -n "$secret" ]; then
                echo "$secret"
                return 0
            fi
        }
    fi
    
    # If all else fails, generate a simple hex string
    echo "Generating simple hex string..." >&2
    echo "zulip_$(date +%s)_$(head -c 16 /dev/urandom 2>/dev/null | xxd -p 2>/dev/null || echo "fallback")"
}

# Check if we have base64 encoded secrets
if [ -n "${ZULIP_SECRETS_B64:-}" ]; then
    echo "Found ZULIP_SECRETS_B64, decoding secrets..."
    
    # Decode the base64 secrets and write to file
    echo "$ZULIP_SECRETS_B64" | base64 -d > "$SECRETS_FILE"
    
    # Validate the decoded file
    if [ ! -f "$SECRETS_FILE" ] || [ ! -s "$SECRETS_FILE" ]; then
        echo "ERROR: Failed to decode ZULIP_SECRETS_B64 or file is empty"
        exit 1
    fi
    
    echo "Successfully decoded base64 secrets"
else
    echo "ZULIP_SECRETS_B64 not found, generating secrets from environment variables..."
    
    # Generate secrets with fallbacks
    echo "Generating Django secret key..."
    DJANGO_SECRET_KEY=$(generate_secret 50)
    echo "Generated Django secret key: ${DJANGO_SECRET_KEY:0:20}..."
    
    echo "Generating shared secret..."
    SHARED_SECRET_VALUE=$(generate_secret 32)
    echo "Generated shared secret: ${SHARED_SECRET_VALUE:0:20}..."
    
    echo "Generating RabbitMQ password..."
    RABBITMQ_PASSWORD_VALUE=$(generate_secret 32)
    echo "Generated RabbitMQ password: ${RABBITMQ_PASSWORD_VALUE:0:20}..."
    
    echo "Generating camo key..."
    CAMO_KEY_VALUE=$(generate_hex_secret 32)
    echo "Generated camo key: ${CAMO_KEY_VALUE:0:20}..."
    
    echo "Generating initial password salt..."
    INITIAL_PASSWORD_SALT_VALUE=$(generate_secret 32)
    echo "Generated initial password salt: ${INITIAL_PASSWORD_SALT_VALUE:0:20}..."
    
    echo "Generating avatar salt..."
    AVATAR_SALT_VALUE=$(generate_secret 32)
    echo "Generated avatar salt: ${AVATAR_SALT_VALUE:0:20}..."
    
    # Create zulip-secrets.conf with required secrets
    sudo tee "$SECRETS_FILE" > /dev/null << EOF
[secrets]
# PostgreSQL database password
postgres_password = ${POSTGRES_PASSWORD:-}

# Django secret key - auto-generated if not provided
secret_key = ${ZULIP_SECRETS_KEY:-$DJANGO_SECRET_KEY}

# Shared secret for internal communication - use environment variable or generate
shared_secret = ${SHARED_SECRET:-$SHARED_SECRET_VALUE}

# Email configuration
email_password = ${EMAIL_PASSWORD:-}

# Social authentication secrets (optional)
social_auth_github_secret = ${GITHUB_CLIENT_SECRET:-}
social_auth_google_secret = ${GOOGLE_CLIENT_SECRET:-}

# File upload secrets (optional)
s3_secret_key = ${S3_SECRET_KEY:-}

# Push notification secrets (optional)
zulip_org_id = ${ZULIP_ORG_ID:-}
zulip_org_key = ${ZULIP_ORG_KEY:-}

# Caching and messaging passwords
memcached_password = ${MEMCACHED_PASSWORD:-}
rabbitmq_password = ${RABBITMQ_PASSWORD:-$RABBITMQ_PASSWORD_VALUE}
redis_password = ${REDIS_PASSWORD:-}

# Additional secrets for production
camo_key = ${CAMO_KEY:-$CAMO_KEY_VALUE}
initial_password_salt = ${INITIAL_PASSWORD_SALT:-$INITIAL_PASSWORD_SALT_VALUE}
avatar_salt = ${AVATAR_SALT:-$AVATAR_SALT_VALUE}
EOF
fi

echo "Secrets file configured successfully."

# Debug: Show what was written to the secrets file
echo "Contents of secrets file:"
sudo cat "$SECRETS_FILE" | grep -E "(^shared_secret|^secret_key|^postgres_password|^avatar_salt)" || echo "No secrets found in file"

# Set proper ownership and permissions (secrets file should be readable only by zulip user)
sudo chown zulip:zulip "$SECRETS_FILE"
sudo chmod 640 "$SECRETS_FILE"

echo "Secrets file created with proper permissions."

# Validate that required secrets are present
echo "Validating required secrets..."

if [ -z "${POSTGRES_PASSWORD:-}" ]; then
    echo "WARNING: POSTGRES_PASSWORD environment variable is not set!"
    echo "Database connection may fail without this credential."
fi

# Verify that the secrets file was created and contains the required secrets
echo "Verifying secrets file contents..."
if [ -f "$SECRETS_FILE" ]; then
    echo "Secrets file created successfully at $SECRETS_FILE"
    
    # Check if shared_secret is present and not empty
    if grep -q "^shared_secret" "$SECRETS_FILE" && ! grep -q "^shared_secret = $" "$SECRETS_FILE" && ! grep -q "^shared_secret =$" "$SECRETS_FILE"; then
        echo "✅ shared_secret is properly configured"
    else
        echo "❌ shared_secret is missing or empty in secrets file"
        exit 1
    fi
    
    # Check if secret_key is present and not empty (use ^ to match line start, avoid matching s3_secret_key)
    if grep -q "^secret_key" "$SECRETS_FILE" && ! grep -q "^secret_key = $" "$SECRETS_FILE" && ! grep -q "^secret_key =$" "$SECRETS_FILE"; then
        echo "✅ secret_key is properly configured"
    else
        echo "❌ secret_key is missing or empty in secrets file"
        echo "Current secret_key line:"
        grep "^secret_key" "$SECRETS_FILE" || echo "No secret_key line found"
        exit 1
    fi
    
    # Check if avatar_salt is present and not empty
    if grep -q "^avatar_salt" "$SECRETS_FILE" && ! grep -q "^avatar_salt = $" "$SECRETS_FILE" && ! grep -q "^avatar_salt =$" "$SECRETS_FILE"; then
        echo "✅ avatar_salt is properly configured"
    else
        echo "❌ avatar_salt is missing or empty in secrets file"
        exit 1
    fi
    
    # Additional validation for postgres_password if it's required
    if [ -n "${POSTGRES_PASSWORD:-}" ]; then
        if grep -q "^postgres_password" "$SECRETS_FILE" && ! grep -q "^postgres_password = $" "$SECRETS_FILE" && ! grep -q "^postgres_password =$" "$SECRETS_FILE"; then
            echo "✅ postgres_password is properly configured"
        else
            echo "❌ postgres_password is missing or empty in secrets file"
            exit 1
        fi
    fi
else
    echo "❌ Secrets file was not created at $SECRETS_FILE"
    exit 1
fi

echo "Secret configuration completed successfully."
